#include <stdio.h>

int main(void)
{
	// 문자 , 정수 , 실수
	//문자 : **char(1바이트, -128 ~ -127)
	//정수 : short(2바이트 , -32000 ~ 32000), **int(4바이트, -21억~21억), long(4바이트, -21억 ~ 21억), long long(8바이트, 무의미할정도로 큼) + %lld사용
	//실수 : float(4바이트), **double(8바이트,소수점 15자리부터 16자리까지 표현가능), long double(8바이트 이상)

	//1바이트 = 8비트(256가지의수) -> 비트 : 데이터를 저장하거나 표현할 수 있는 가장 작은 단위이며 1비트는 0또는1중의 하나의 값만 저장가능 경우의 수 2
	//signed기준 (-128부터 128) / unsigned기준 (0부터 255)

	unsigned int maxnumber = 2200000000;
	printf("%u\n", maxnumber);

	//signed : 모든 왼쪽 비트는 부호비트로 적용됨(기본적용)
	//범위 + @ : 부호비트는 0을 양수로 1을 음수로 읽는다 / ㅁㅁㅁㅁㅁㅁㅁㅁ(맨왼쪽은 부호비트) 
	// 따라서 양수(부호비트가0)인 경우 128 - 1인 0부터 127까지, 음수(부호비트가1)는 음수는 -1부터 시작이므로  -1부터 -128까지이다. @둘다 128가지 
	
	//unsigned : 모든 비트는 숫자를 표현할때 사용됨(변경필요) -> 그래서 음수쪽에 있는 비트들을 양수로 이동, 따라서 int는 21억에서 42억가지로 증가 + %u사용
	//범위 : 0부터 2의 n승 -1


	//자료형의 자동형 변환
	double change_number = 10;
	printf("%f\n", change_number); //double : 소수점 15~16자리 but %f : 16자리로 출력 + 그래서 %.15f 사용하면 15자리로 출력

	//자동형 변환2 (소수부의 손실)
	int change_number2 = 5.1123;
	printf("%d\n", change_number2);

	//자료형과 초기화될 데이터의 자료형이 다르다면 변수자료형에 맞춰서 자동 형변환이 일어난다.

	//명시적 형변환
	printf("%d\n", (int)1.1234);
	printf("%d\n", (short)1.1234); //short : 메모리절약용 + 작은범위에서 움직일때
	printf("%f\n", (double)22); //double : 메모리큼 그러나 소수점 자리가 많음, 따라서 정밀한 작업용
	printf("%f\n", (float)22); //float : 소수점 6~7자리, 부팅속도중요? -> 메모리 절약
	return 0;
}